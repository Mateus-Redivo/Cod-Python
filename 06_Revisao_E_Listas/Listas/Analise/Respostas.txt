1. Nomes de Variáveis

Olhando a função calcular_nota_estudante(e, c, p, b=None, d=5), os nomes dos parâmetros são muito confusos. Melhorando:

- e → nome_estudante - deixa claro que esperamos o nome do aluno
- c → disciplina - indica qual matéria estamos avaliando
- p → pontos_participacao - mostra que são pontos extras de participação
- b → tipo_bonus - indica qual tipo de bônus especial (olimpíada, concurso)
- d → numero_faltas - deixa explícito que são faltas do aluno

Com isso, a função ficaria: calcular_nota_estudante(nome_estudante, disciplina, pontos_participacao, tipo_bonus=None, numero_faltas=5)

2. Responsabilidade Única

Essa função está fazendo trabalho demais! Ela faz pelo menos 4 coisas diferentes:

Coisa 1 - Buscar dados do estudante
- Procura o estudante na lista
- Extrai suas notas e informações

Coisa 2 - Calcular média e bônus
- Calcula a média ponderada das 3 notas
- Aplica vários tipos de bônus diferentes

Coisa 3 - Aplicar penalidades
- Desconta pontos por faltas
- Garante que a nota não ultrapasse 100

Coisa 4 - Exibir resultados
- Imprime todas as informações na tela

Como dividir:
def buscar_estudante(nome):
    # Só procura e retorna os dados do aluno
    
def calcular_media_ponderada(notas):
    # Só calcula a média
    
def calcular_bonus_total(disciplina, pontos, tipo_bonus, veterano, modalidade):
    # Só calcula os bônus
    
def aplicar_ajustes_finais(nota, faltas):
    # Aplica descontos e limita a nota
    
def exibir_resultado(estudante, nota, status):
    # Só cuida da exibição


3. Magic Numbers

O código está cheio de números "mágicos" sem explicação. Veja alguns:

- 15, 10, 5 - limites de pontos para bônus de matemática
- 80, 60 - notas mínimas para aprovação
- 0.3, 0.4, 0.3 - pesos das provas na média
- 100 - nota máxima
- 0.5 - desconto por falta

Como melhorar com constantes:

# Pesos das avaliações
PESO_PROVA_1 = 0.3
PESO_PROVA_2 = 0.4
PESO_PROVA_3 = 0.3

# Critérios de aprovação
NOTA_APROVACAO_DISTINCAO = 80
NOTA_APROVACAO_REGULAR = 60
NOTA_MAXIMA_PERMITIDA = 100

# Bônus por disciplina
BONUS_MAT_ALTO = 5
BONUS_MAT_MEDIO = 3
BONUS_MAT_BAIXO = 1

# Penalidades
DESCONTO_POR_FALTA = 0.5
LIMITE_FALTAS_SEM_DESCONTO = 5

# Bônus especiais
BONUS_VETERANO = 2
BONUS_ONLINE = 1
BONUS_OLIMPIADA = 10
BONUS_CONCURSO = 5

Assim qualquer pessoa entende o que cada número significa!


4. Estrutura de Dados

A lista atual `["João", 85, 90, 78, "presencial", True]` é confusa. Você precisa saber que a posição [1] é nota 1, [2] é nota 2, etc. Isso dá muito erro!

Solução melhor - usar matriz organizada:

# Criar matriz de estudantes onde cada linha é um aluno
# Colunas: [nome, nota1, nota2, nota3, modalidade_cod, veterano_cod, faltas]
# modalidade: 0=presencial, 1=online, 2=hibrido
# veterano: 0=não, 1=sim

matriz_estudantes = [
    ["João", 85, 90, 78, 0, 1, 3],
    ["Maria", 92, 88, 95, 1, 0, 1],
    ["Pedro", 70, 75, 80, 0, 1, 5]
]

# Definir índices como constantes para facilitar acesso
NOME = 0
NOTA_1 = 1
NOTA_2 = 2
NOTA_3 = 3
MODALIDADE = 4
VETERANO = 5
FALTAS = 6

# Acessar fica muito mais claro:
estudante = matriz_estudantes[0]  # pega João
nota = estudante[NOTA_1]  # pega nota da prova 1
nome = estudante[NOME]    # pega o nome


5. Complexidade do Código

A função tem IF dentro de IF dentro de IF, deixando o codigo difícil de seguir


Ideia 1 - Usar "early return" para sair cedo

Ao invés de aninhar IFs, retorna logo quando encontrar um problema:

def processar_estudante(nome):
    estudante = buscar_estudante(nome)
    
    if not estudante:
        return None  # sai logo se não encontrou
    
    if tem_nota_invalida(estudante):
        return None  # sai logo se notas inválidas
    
    # Agora processa normalmente, sem tanto aninhamento
    media = calcular_media(estudante)
    return media


6. Validação de Entrada

O código aceita qualquer coisa sem verificar! Poderia quebrar facilmente. Validações necessárias:

def validar_nota(nota):
    """Verifica se a nota está entre 0 e 100"""
    if not isinstance(nota, (int, float)):
        raise ValueError("A nota precisa ser um número!")
    if nota < 0 or nota > 100:
        raise ValueError("A nota deve estar entre 0 e 100!")
    return True

def validar_modalidade(modalidade):
    """Verifica se a modalidade é válida"""
    opcoes_validas = ["presencial", "online", "hibrido"]
    if modalidade not in opcoes_validas:
        raise ValueError(f"Modalidade deve ser: {', '.join(opcoes_validas)}")
    return True

def validar_disciplina(disciplina):
    """Verifica se a disciplina existe"""
    disciplinas_aceitas = ["matematica", "portugues", "ciencias"]
    if disciplina not in disciplinas_aceitas:
        raise ValueError(f"Disciplina desconhecida: {disciplina}")
    return True

def validar_faltas(faltas):
    """Verifica se o número de faltas faz sentido"""
    if faltas < 0:
        raise ValueError("Número de faltas não pode ser negativo!")
    if faltas > 100:
        raise ValueError("Número de faltas muito alto!")
    return True


7. Cálculo de Bônus

O código repete a mesma lógica 3 vezes (uma para cada matéria). É código duplicado!

O problema:
if c == "matematica":
    if p >= 15: bonus = 5
    elif p >= 10: bonus = 3
    # ...
elif c == "portugues":
    if p >= 20: bonus = 4
    elif p >= 15: bonus = 2
    # ... MESMA LÓGICA, SÓ MUDA OS NÚMEROS!

A solução - criar uma função genérica:

def calcular_bonus_por_faixa(pontos, faixas):
    """
    Calcula bônus baseado em faixas de pontuação
    faixas = [(pontos_minimos, bonus), ...]
    """
    for pontos_min, valor_bonus in faixas:
        if pontos >= pontos_min:
            return valor_bonus
    return 0

# Definir as faixas de cada matéria
FAIXAS_MATEMATICA = [(15, 5), (10, 3), (5, 1)]
FAIXAS_PORTUGUES = [(20, 4), (15, 2), (10, 1)]
FAIXAS_CIENCIAS = [(12, 6), (8, 3)]

# Usar é super simples:
bonus_mat = calcular_bonus_por_faixa(pontos, FAIXAS_MATEMATICA)
bonus_port = calcular_bonus_por_faixa(pontos, FAIXAS_PORTUGUES)

Agora não tem repetição e fica fácil adicionar novas matérias!


8. Código Duplicado

Vejo repetição em vários lugares:

Duplicação 1 - Verificar notas negativas
# Aparece 3 vezes no código original:
if n1 < 0 or n2 < 0 or n3 < 0:
    continue

# Solução:
def todas_notas_validas(notas):
    return all(nota >= 0 for nota in notas)

if not todas_notas_validas([n1, n2, n3]):
    continue

Duplicação 2 - Verificar limites de pontos para bônus

A lógica `if pontos >= X: bonus = Y` se repete várias vezes. Já mostrei a solução acima com `calcular_bonus_por_faixa`.

Duplicação 3 - Acessar elementos da lista
estudantes[i][0]  # nome
estudantes[i][1]  # nota 1
estudantes[i][2]  # nota 2
# ... isso se repete muitas vezes

# Solução: usar desempacotamento
nome, n1, n2, n3, modalidade, veterano = estudantes[i]


9. Testes

Para facilitar testes, precisa separar a lógica da entrada/saída. Agora a função tem `print()` no meio, o que dificulta testar.

Mudanças necessárias:

1. Separar cálculo de exibição
# Ruim (mistura tudo):
def calcular_nota(estudante):
    nota = fazer_calculos()
    print(f"Nota: {nota}")  
    return nota

# Bom (separa responsabilidades):
def calcular_nota(estudante):
    return fazer_calculos()  

def exibir_nota(estudante, nota):
    print(f"Nota: {nota}")

2. Não depender de dados fixos
# Ruim (dados embutidos):
def calcular_nota(nome):
    estudantes = [["João", 85, ...]]  

# Bom (recebe os dados):
def calcular_nota(estudante):  
    return calcular(estudante)

3. Retornar valores ao invés de imprimir
# Agora posso testar assim:
def test_calculo_media():
    estudante = {"nota1": 80, "nota2": 90, "nota3": 70}
    resultado = calcular_media(estudante)
    assert resultado == 80  # verifica se está correto!


10. Padrão Strategy com Dicionários e Matrizes

O padrão Strategy (Estratégia) foi o escolhido.

O problema atual:

Cada disciplina tem regras diferentes de bônus. Hoje está tudo misturado em IFs enormes e confusos.

A solução com Strategy usando estruturas de dados:

# PASSO 1: Definir as regras de cada disciplina em matrizes
# Cada matriz tem linhas: [pontos_minimos, bonus_concedido]

REGRAS_MATEMATICA = [
    [15, 5],  # >= 15 pontos → bônus de 5
    [10, 3],  # >= 10 pontos → bônus de 3
    [5, 1]    # >= 5 pontos  → bônus de 1
]

REGRAS_PORTUGUES = [
    [20, 4],  # >= 20 pontos → bônus de 4
    [15, 2],  # >= 15 pontos → bônus de 2
    [10, 1]   # >= 10 pontos → bônus de 1
]

REGRAS_CIENCIAS = [
    [12, 6],  # >= 12 pontos → bônus de 6
    [8, 3]    # >= 8 pontos  → bônus de 3
]

# PASSO 2: Criar funções estratégia para cada disciplina
# Cada função sabe como calcular o bônus da sua disciplina

def estrategia_matematica(pontos):
    """Estratégia de cálculo de bônus para Matemática"""
    for regra in REGRAS_MATEMATICA:
        if pontos >= regra[0]:
            return regra[1]
    return 0

def estrategia_portugues(pontos):
    """Estratégia de cálculo de bônus para Português"""
    for regra in REGRAS_PORTUGUES:
        if pontos >= regra[0]:
            return regra[1]
    return 0

def estrategia_ciencias(pontos):
    """Estratégia de cálculo de bônus para Ciências"""
    for regra in REGRAS_CIENCIAS:
        if pontos >= regra[0]:
            return regra[1]
    return 0

# PASSO 3: Dicionário que mapeia disciplina → função estratégia
# Este é o coração do padrão Strategy!

ESTRATEGIAS_BONUS = {
    "matematica": estrategia_matematica,
    "portugues": estrategia_portugues,
    "ciencias": estrategia_ciencias
}

# PASSO 4: Função principal que usa o padrão Strategy
# Ela delega o cálculo para a estratégia correta

def calcular_bonus(disciplina, pontos_participacao):
    """
    Calcula bônus usando o padrão Strategy.
    Seleciona a estratégia certa e executa.
    """
    # Busca a estratégia no dicionário
    estrategia = ESTRATEGIAS_BONUS.get(disciplina)
    
    if estrategia is None:
        return 0  # disciplina não encontrada
    
    # Executa a estratégia escolhida
    return estrategia(pontos_participacao)

# EXEMPLOS DE USO:
bonus_mat = calcular_bonus("matematica", 12)  # retorna 3
bonus_port = calcular_bonus("portugues", 18)  # retorna 2
bonus_cien = calcular_bonus("ciencias", 10)   # retorna 3

# VERSÃO ALTERNATIVA: Strategy com matriz unificada
# Se preferir, pode usar uma matriz ao invés de funções separadas

TABELA_ESTRATEGIAS = {
    "matematica": [[15, 5], [10, 3], [5, 1]],
    "portugues": [[20, 4], [15, 2], [10, 1]],
    "ciencias": [[12, 6], [8, 3]]
}

def calcular_bonus_v2(disciplina, pontos):
    """Versão simplificada usando só matriz"""
    regras = TABELA_ESTRATEGIAS.get(disciplina, [])
    
    for regra in regras:
        if pontos >= regra[0]:
            return regra[1]
    
    return 0
