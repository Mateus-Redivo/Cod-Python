EXERCÍCIO 1 
Explique brevemente o que são "code smells" e dê exemplos de como identificá-los:
a) Magic Numbers:
b) Código Duplicado:
c) Função com múltiplas responsabilidades:
d) Falta de tratamento de exceções:

EXERCÍCIO 2 
Analise as afirmativas sobre refatoração de código:
(   ) É sempre necessário adicionar novos recursos ao refatorar
(   ) A refatoração deve manter o comportamento funcional do código
(   ) Magic numbers devem ser substituídos por constantes nomeadas
(   ) Duplicação de código é aceitável se for pequena
(   ) O princípio DRY (Don't Repeat Yourself) deve ser aplicado sempre que possível

EXERCÍCIO 3
Liste 5 técnicas fundamentais para eliminar duplicação de código:
1. 
2. 
3. 
4. 
5. 

EXERCÍCIO 4 
Defina os seguintes princípios de código limpo e dê um exemplo prático de cada:

a) SRP (Single Responsibility Principle):
   Definição: 
   Exemplo: 

b) DRY (Don't Repeat Yourself):
   Definição: 
   Exemplo: 

c) KISS (Keep It Simple, Stupid):
   Definição: 
   Exemplo: 

d) YAGNI (You Aren't Gonna Need It):
   Definição: 
   Exemplo:

EXERCÍCIO 5 
Reescreva o código abaixo aplicando boas práticas de refatoração:

Código original:

def processar_pedido():
    nome = input("Nome: ")
    preco = float(input("Preço: "))
    if preco > 100:
        desconto = preco * 0.10
    else:
        desconto = 0
    total = preco - desconto
    print(f"Cliente: {nome}, Total: R$ {total}")
    return total


Código refatorado:


EXERCÍCIO 6 
Identifique os code smells no código abaixo e proponha melhorias:


cargo = input("Cargo: ").lower()
if cargo == "gerente":
    bonus = salario * 0.20
    ir = salario * 0.275
elif cargo == "supervisor":
    bonus = salario * 0.15
    ir = salario * 0.15
elif cargo == "operador":
    bonus = salario * 0.10
    ir = salario * 0.075


Code smells identificados:
1. 
2. 
3. 

Código melhorado:


EXERCÍCIO 7 
Explique quando aplicar cada estratégia de refatoração:
a) Extract Function (Extrair Função):
   Quando usar: 
   
b) Replace Conditional with Dictionary/Map:
   Quando usar: 
   
c) Introduce Parameter Object:
   Quando usar: 
   
d) Replace Magic Number with Symbolic Constant:
   Quando usar: 

EXERCÍCIO 8 
Analise o código abaixo e identifique violações do princípio SRP:


def cadastrar_usuario():
    # Validação de entrada
    nome = input("Nome: ").strip()
    while len(nome) < 3:
        print("Nome deve ter pelo menos 3 caracteres!")
        nome = input("Nome: ").strip()
    
    email = input("Email: ")
    while "@" not in email:
        print("Email inválido!")
        email = input("Email: ")
    
    # Cálculos
    idade = int(input("Idade: "))
    categoria = "adulto" if idade >= 18 else "menor"
    
    # Banco de dados
    conexao = conectar_bd()
    cursor = conexao.cursor()
    cursor.execute("INSERT INTO usuarios...")
    
    # Relatório
    with open("relatorio.txt", "a") as arquivo:
        arquivo.write(f"Usuário {nome} cadastrado\n")
    
    # Email
    enviar_email_confirmacao(email)


Violações identificadas:
1. 
2. 
3. 
4. 

Proposta de refatoração (separação em funções):


EXERCÍCIO 9 
Complete o código de uma função genérica de validação que elimine duplicação:


def validar_entrada(prompt, validador, mensagem_erro):
    """
    Função genérica para validar entrada do usuário
    
    Args:
        prompt: Mensagem para solicitar entrada
        validador: Função que retorna True se entrada for válida
        mensagem_erro: Mensagem de erro para entrada inválida
    
    Returns:
        Entrada validada
    """
    # Complete o código aqui:
    

# Exemplo de uso:
def validar_nome(nome):
    return len(nome.strip()) >= 3 and nome.isalpha()

def validar_idade(idade_str):
    return idade_str.isdigit() and 0 <= int(idade_str) <= 120

nome = validar_entrada("Nome: ", validar_nome, "Nome deve ter 3+ caracteres!")
idade = validar_entrada("Idade: ", validar_idade, "Idade inválida!")


EXERCÍCIO 10 
Compare as duas versões do código e explique qual é melhor e por quê:

Versão A:

def calcular_bonus(cargo, salario):
    if cargo == "gerente":
        return salario * 0.20
    elif cargo == "supervisor":
        return salario * 0.15
    elif cargo == "operador":
        return salario * 0.10
    else:
        return 0


Versão B:

BONUS_POR_CARGO = {
    "gerente": 0.20,
    "supervisor": 0.15,
    "operador": 0.10
}

def calcular_bonus(cargo, salario):
    multiplicador = BONUS_POR_CARGO.get(cargo, 0)
    return salario * multiplicador


Análise comparativa:
Versão melhor: 
Justificativas:
1. 
2. 
3. 

EXERCÍCIO 11 
Identifique e corrija os problemas no tratamento de exceções:


def dividir_numeros():
    a = int(input("Primeiro número: "))
    b = int(input("Segundo número: "))
    resultado = a / b
    print(f"Resultado: {resultado}")


Problemas identificados:
1. 
2. 

Código corrigido:


EXERCÍCIO 12 
Pratique separação de responsabilidades - divida esta função em funções menores:


def processar_vendas():
    total_vendas = 0
    
    for i in range(3):
        print(f"\n--- Venda {i+1} ---")
        produto = input("Produto: ").strip()
        while len(produto) < 2:
            print("Nome do produto muito curto!")
            produto = input("Produto: ").strip()
        
        preco = float(input("Preço: "))
        while preco <= 0:
            print("Preço deve ser positivo!")
            preco = float(input("Preço: "))
        
        desconto_pct = float(input("Desconto %: "))
        desconto_valor = preco * (desconto_pct / 100)
        preco_final = preco - desconto_valor
        
        total_vendas += preco_final
        
        print(f"Produto: {produto}")
        print(f"Preço original: R$ {preco:.2f}")
        print(f"Desconto: R$ {desconto_valor:.2f}")
        print(f"Preço final: R$ {preco_final:.2f}")
    
    print(f"\nTotal de vendas: R$ {total_vendas:.2f}")
    
    with open("vendas.txt", "w") as arquivo:
        arquivo.write(f"Total do dia: R$ {total_vendas:.2f}\n")


Funções extraídas (escreva as assinaturas e responsabilidades):
1. 
2. 
3. 
4. 
5. 

EXERCÍCIO 13 
Analise este código e explique como aplicar o princípio "Separation of Concerns":


def app_vendas():
    produtos = []
    
    while True:
        print("\n=== SISTEMA DE VENDAS ===")
        print("1. Cadastrar produto")
        print("2. Listar produtos") 
        print("3. Calcular total")
        print("4. Gerar relatório")
        print("5. Sair")
        
        opcao = input("Escolha uma opção: ")
        
        if opcao == "1":
            nome = input("Nome: ")
            preco = float(input("Preço: "))
            produtos.append({"nome": nome, "preco": preco})
            print("Produto cadastrado!")
            
        elif opcao == "2":
            for produto in produtos:
                print(f"{produto['nome']}: R$ {produto['preco']}")
                
        elif opcao == "3":
            total = sum(p["preco"] for p in produtos)
            print(f"Total: R$ {total}")
            
        elif opcao == "4":
            with open("relatorio.txt", "w") as f:
                f.write("=== RELATÓRIO DE PRODUTOS ===\n")
                for produto in produtos:
                    f.write(f"{produto['nome']}: R$ {produto['preco']}\n")
            print("Relatório gerado!")
            
        elif opcao == "5":
            break


Camadas identificadas para separação:
1. Camada de Apresentação (UI):
2. Camada de Lógica de Negócio:
3. Camada de Dados:

Estrutura proposta:


EXERCÍCIO 14 
Complete o exemplo de refatoração usando o padrão Strategy:


# Antes da refatoração (com múltiplos ifs)
def calcular_frete(distancia, tipo_entrega):
    if tipo_entrega == "normal":
        return distancia * 2.5
    elif tipo_entrega == "expressa":
        return distancia * 4.0
    elif tipo_entrega == "premium":
        return distancia * 6.0
    else:
        return 0

# Depois da refatoração (Strategy Pattern)
# Complete o código:

class CalculadoraFrete:
    def __init__(self):
        self.estrategias = {
            # Complete aqui
        }
    
    def calcular(self, distancia, tipo_entrega):
        # Complete aqui
        pass

# Funções de estratégia:
def frete_normal(distancia):
    # Complete aqui
    pass

def frete_expresso(distancia):
    # Complete aqui
    pass

def frete_premium(distancia):
    # Complete aqui
    pass


EXERCÍCIO 15 
Análise de código: identifique TODOS os problemas e proponha soluções completas:


def sistema():
    usuarios = []
    while True:
        nome = input("Nome (ou 'sair'): ")
        if nome == "sair":
            break
        idade = int(input("Idade: "))
        salario = float(input("Salário: "))
        
        if idade >= 18:
            if salario > 5000:
                categoria = "A"
                desconto = salario * 0.2
            elif salario > 2000:
                categoria = "B" 
                desconto = salario * 0.1
            else:
                categoria = "C"
                desconto = salario * 0.05
        else:
            categoria = "Menor"
            desconto = 0
            
        liquido = salario - desconto
        usuarios.append([nome, idade, salario, categoria, liquido])
        
        print(f"{nome} - Categoria {categoria} - Líquido: R$ {liquido}")

    print("\n=== RELATÓRIO FINAL ===")
    for usuario in usuarios:
        print(f"Nome: {usuario[0]}, Idade: {usuario[1]}, Líquido: R$ {usuario[4]}")
        
    arquivo = open("usuarios.txt", "w")
    for usuario in usuarios:
        arquivo.write(f"{usuario[0]};{usuario[1]};{usuario[4]}\n")
    arquivo.close()


Problemas identificados:
1. 
2. 
3. 
4. 
5. 
6. 

Código refatorado (versão completa):


