1. Analisando o código abaixo, qual é o principal "code smell" (sinal de código problemático)?

cargo = input("Cargo (gerente/supervisor/operador): ").lower()
while cargo not in ["gerente", "supervisor", "operador"]:
    print("Cargo inválido!")
    cargo = input("Cargo (gerente/supervisor/operador): ").lower()

if cargo == "gerente":
    bonus = salario * 0.20
elif cargo == "supervisor":
    bonus = salario * 0.15
else:
    bonus = salario * 0.10

A) Falta de comentários no código
B) Números mágicos (0.20, 0.15, 0.10) sem contexto claro
C) Uso inadequado de estruturas condicionais
D) Variáveis mal nomeadas



2. No contexto de refatoração, qual é a melhor estratégia para eliminar repetições de validação como no código abaixo?

# Produto 1
nome1 = input("Nome: ").strip()
while nome1 == "" or len(nome1) < 2:
    print("Nome deve ter pelo menos 2 caracteres!")
    nome1 = input("Nome: ").strip()

# Produto 2  
nome2 = input("Nome: ").strip()
while nome2 == "" or len(nome2) < 2:
    print("Nome deve ter pelo menos 2 caracteres!")
    nome2 = input("Nome: ").strip()

A) Usar variáveis globais para armazenar as validações
B) Criar uma função de validação que pode ser reutilizada
C) Remover as validações para simplificar o código
D) Copiar e colar o código quantas vezes for necessário



3. Observe este código com problemas estruturais:

def processar_funcionario():
    nome = input("Nome: ")
    salario = float(input("Salário: "))
    if salario <= 2000:
        ir = 0
    elif salario <= 4000:
        ir = salario * 0.075
    else:
        ir = salario * 0.15
    inss = salario * 0.11
    liquido = salario - ir - inss
    print(f"Nome: {nome}, Líquido: R$ {liquido}")
    return liquido

Qual é a principal violação dos princípios de código limpo?
A) Falta de tratamento de exceções
B) A função mistura entrada, processamento e saída (múltiplas responsabilidades)
C) Uso de números mágicos
D) Todas as alternativas anteriores



4. Em refatoração, qual técnica é mais adequada para resolver o problema do código da questão anterior?
A) Adicionar mais comentários explicativos
B) Separar as responsabilidades em funções menores e específicas
C) Usar apenas uma linha de código para tudo
D) Remover todas as validações



5. Analisando este padrão repetitivo complexo:

if categoria == "higiene":
    desconto = 0.05
elif categoria == "alimenticio":
    desconto = 0.02
elif categoria == "limpeza":
    desconto = 0.0
else:
    desconto = 0.0

Qual é a melhor abordagem para refatorar este código repetido em vários locais?
A) Usar um dicionário para mapear categorias e descontos
B) Criar múltiplas variáveis globais
C) Repetir o if/elif em cada função que precisar
D) Usar apenas valores fixos sem verificação



6. Qual problema crítico existe neste código de validação?

codigo = input("Código: ")
while len(codigo) != 6 or not codigo.isdigit():
    print("Código deve ter 6 dígitos!")
    codigo = input("Código: ")

preco = int(input("Preço: "))
if preco <= 0:
    print("Preço inválido!")

A) A validação do código está correta, mas falta tratamento de exceção no preço
B) O while está correto, mas deveria usar if
C) Não há problemas no código
D) A lógica do while está invertida



7. Em refatoração, qual é o princípio violado no código abaixo?

def cadastrar_produto():
    # 50 linhas de código fazendo:
    # - Validar dados de entrada
    # - Calcular descontos
    # - Atualizar estoque
    # - Gerar relatório
    # - Enviar email
    # - Fazer backup

A) DRY (Don't Repeat Yourself)
B) SRP (Single Responsibility Principle)
C) YAGNI (You Aren't Gonna Need It)
D) KISS (Keep It Simple, Stupid)



8. Observe este código com tratamento inadequado de dados:

vendas_mes = 0
for i in range(3):
    preco = float(input("Preço da venda: "))
    desconto = float(input("Desconto %: "))
    preco_final = preco - (preco * desconto / 100)
    vendas_mes = vendas_mes + preco_final
    comissao = preco_final * 0.05

Qual é o maior problema estrutural deste código?
A) Falta de validação de entrada
B) Loop desnecessário
C) Mistura de lógica de negócio com interface do usuário
D) Uso inadequado de variáveis



9. Para refatorar validações complexas e repetitivas como a mostrada abaixo, qual é a melhor estratégia?

nome = input("Nome: ").strip()
while len(nome) < 3 or not all(c.isalpha() or c.isspace() for c in nome):
    print("Nome inválido!")
    nome = input("Nome: ").strip()

A) Manter a validação inline em cada local que precisa
B) Criar uma função genérica validar_entrada(prompt, validador, mensagem_erro)
C) Usar apenas try/except sem validação prévia
D) Remover a validação para simplificar



10. Qual das alternativas representa a melhor refatoração para códigos com múltiplos cálculos similares repetidos?

# Funcionário 1
if cargo1 == "gerente":
    bonus1 = salario1 * 0.20
elif cargo1 == "supervisor":
    bonus1 = salario1 * 0.15
# ... mais cálculos repetidos para funcionário 2, 3, etc.

A) Usar classes e métodos para encapsular os cálculos
B) Criar funções específicas para cada tipo de cálculo
C) Usar estruturas de dados (listas/dicionários) com funções de processamento
D) Todas as alternativas anteriores são válidas